-- Fix Security Definer Functions - Complete Verified Script
-- Generated by direct database query with full function definitions

-- =============================================================================
-- RECREATE FUNCTIONS WITHOUT SECURITY DEFINER
-- =============================================================================

-- Fix create_booking_with_relations function - remove SECURITY DEFINER
DROP FUNCTION IF EXISTS public.create_booking_with_relations(booking_data jsonb, parent_data jsonb, athletes_data jsonb[], focus_area_ids integer[], apparatus_ids integer[], side_quest_ids integer[]) CASCADE;

-- Recreate without SECURITY DEFINER:
CREATE OR REPLACE FUNCTION public.create_booking_with_relations(booking_data jsonb, parent_data jsonb, athletes_data jsonb[], focus_area_ids integer[], apparatus_ids integer[] DEFAULT '{}'::integer[], side_quest_ids integer[] DEFAULT '{}'::integer[])
 RETURNS jsonb
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
  booking_id INTEGER;
  parent_id INTEGER;
  athlete_id INTEGER;
  athlete_data JSONB;
  result JSONB;
BEGIN
  -- Start transaction (implicit in function)
  
  -- 1. Create or find parent
  SELECT id INTO parent_id 
  FROM parents 
  WHERE email = (parent_data->>'email')::TEXT;
  
  IF parent_id IS NULL THEN
    INSERT INTO parents (
      first_name,
      last_name, 
      email,
      phone,
      emergency_contact_name,
      emergency_contact_phone,
      created_at,
      updated_at
    ) VALUES (
      (parent_data->>'first_name')::TEXT,
      (parent_data->>'last_name')::TEXT,
      (parent_data->>'email')::TEXT,
      (parent_data->>'phone')::TEXT,
      (parent_data->>'emergency_contact_name')::TEXT,
      (parent_data->>'emergency_contact_phone')::TEXT,
      NOW(),
      NOW()
    ) RETURNING id INTO parent_id;
  ELSE
    -- Update existing parent with latest info
    UPDATE parents SET
      first_name = (parent_data->>'first_name')::TEXT,
      last_name = (parent_data->>'last_name')::TEXT,
      phone = (parent_data->>'phone')::TEXT,
      emergency_contact_name = (parent_data->>'emergency_contact_name')::TEXT,
      emergency_contact_phone = (parent_data->>'emergency_contact_phone')::TEXT,
      updated_at = NOW()
    WHERE id = parent_id;
  END IF;

  -- 2. Create booking
  INSERT INTO bookings (
    lesson_type,
    parent_first_name,
    parent_last_name,
    parent_email,
    parent_phone,
    emergency_contact_name,
    emergency_contact_phone,
    preferred_date,
    preferred_time,
    amount,
    status,
    payment_status,
    attendance_status,
    booking_method,
    waiver_signed,
    waiver_signed_at,
    waiver_signature_name,
    reservation_fee_paid,
    paid_amount,
    special_requests,
    admin_notes,
    dropoff_person_name,
    dropoff_person_relationship,
    dropoff_person_phone,
    pickup_person_name,
    pickup_person_relationship,
    pickup_person_phone,
    alt_pickup_person_name,
    alt_pickup_person_relationship,
    alt_pickup_person_phone,
    safety_verification_signed,
    safety_verification_signed_at,
    stripe_session_id,
    created_at,
    updated_at
  ) VALUES (
    (booking_data->>'lesson_type')::TEXT,
    (booking_data->>'parent_first_name')::TEXT,
    (booking_data->>'parent_last_name')::TEXT,
    (booking_data->>'parent_email')::TEXT,
    (booking_data->>'parent_phone')::TEXT,
    (booking_data->>'emergency_contact_name')::TEXT,
    (booking_data->>'emergency_contact_phone')::TEXT,
    (booking_data->>'preferred_date')::DATE,
    (booking_data->>'preferred_time')::TIME,
    (booking_data->>'amount')::NUMERIC,
    COALESCE((booking_data->>'status')::booking_status, 'pending'),
    COALESCE((booking_data->>'payment_status')::payment_status, 'unpaid'),
    COALESCE((booking_data->>'attendance_status')::attendance_status, 'pending'),
    COALESCE((booking_data->>'booking_method')::TEXT, 'online'),
    COALESCE((booking_data->>'waiver_signed')::BOOLEAN, false),
    (booking_data->>'waiver_signed_at')::TIMESTAMP,
    (booking_data->>'waiver_signature_name')::TEXT,
    COALESCE((booking_data->>'reservation_fee_paid')::BOOLEAN, false),
    COALESCE((booking_data->>'paid_amount')::NUMERIC, 0.00),
    (booking_data->>'special_requests')::TEXT,
    (booking_data->>'admin_notes')::TEXT,
    (booking_data->>'dropoff_person_name')::TEXT,
    (booking_data->>'dropoff_person_relationship')::TEXT,
    (booking_data->>'dropoff_person_phone')::TEXT,
    (booking_data->>'pickup_person_name')::TEXT,
    (booking_data->>'pickup_person_relationship')::TEXT,
    (booking_data->>'pickup_person_phone')::TEXT,
    (booking_data->>'alt_pickup_person_name')::TEXT,
    (booking_data->>'alt_pickup_person_relationship')::TEXT,
    (booking_data->>'alt_pickup_person_phone')::TEXT,
    COALESCE((booking_data->>'safety_verification_signed')::BOOLEAN, false),
    (booking_data->>'safety_verification_signed_at')::TIMESTAMP,
    (booking_data->>'stripe_session_id')::TEXT,
    NOW(),
    NOW()
  ) RETURNING id INTO booking_id;

  -- 3. Create athletes and link to booking
  FOREACH athlete_data IN ARRAY athletes_data
  LOOP
    -- Create athlete
    INSERT INTO athletes (
      parent_id,
      name,
      first_name,
      last_name,
      date_of_birth,
      allergies,
      experience,
      created_at,
      updated_at
    ) VALUES (
      parent_id,
      (athlete_data->>'name')::TEXT,
      (athlete_data->>'first_name')::TEXT,
      (athlete_data->>'last_name')::TEXT,
      (athlete_data->>'date_of_birth')::DATE,
      (athlete_data->>'allergies')::TEXT,
      (athlete_data->>'experience')::TEXT,
      NOW(),
      NOW()
    ) RETURNING id INTO athlete_id;

    -- Link athlete to booking
    INSERT INTO booking_athletes (
      booking_id,
      athlete_id,
      slot_order
    ) VALUES (
      booking_id,
      athlete_id,
      (SELECT COALESCE(MAX(slot_order), 0) + 1 FROM booking_athletes WHERE booking_id = booking_id)
    );
  END LOOP;

  -- 4. Link focus areas to booking
  IF array_length(focus_area_ids, 1) > 0 THEN
    INSERT INTO booking_focus_areas (booking_id, focus_area_id)
    SELECT booking_id, UNNEST(focus_area_ids);
  END IF;

  -- 5. Link apparatus to booking
  IF array_length(apparatus_ids, 1) > 0 THEN
    INSERT INTO booking_apparatus (booking_id, apparatus_id)
    SELECT booking_id, UNNEST(apparatus_ids);
  END IF;

  -- 6. Link side quests to booking
  IF array_length(side_quest_ids, 1) > 0 THEN
    INSERT INTO booking_side_quests (booking_id, side_quest_id)
    SELECT booking_id, UNNEST(side_quest_ids);
  END IF;

  -- Return booking info
  result := jsonb_build_object(
    'booking_id', booking_id,
    'parent_id', parent_id,
    'success', true
  );

  RETURN result;
  
EXCEPTION
  WHEN OTHERS THEN
    -- Log error and re-raise
    RAISE EXCEPTION 'Error creating booking: %', SQLERRM;
END;
$function$;


-- Grant execute permission to service_role
GRANT EXECUTE ON FUNCTION public.create_booking_with_relations(booking_data jsonb, parent_data jsonb, athletes_data jsonb[], focus_area_ids integer[], apparatus_ids integer[], side_quest_ids integer[]) TO service_role;

-- =============================================================================

-- Fix reset_athlete_waiver_signed function - remove SECURITY DEFINER
DROP FUNCTION IF EXISTS public.reset_athlete_waiver_signed() CASCADE;

-- Recreate without SECURITY DEFINER:
CREATE OR REPLACE FUNCTION public.reset_athlete_waiver_signed()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'public'
AS $function$
BEGIN
  -- When a waiver is deleted, check if the athlete has any other waivers
  IF OLD.athlete_id IS NOT NULL THEN
    -- Check if there are any other waivers for this athlete
    IF NOT EXISTS (SELECT 1 FROM waivers WHERE athlete_id = OLD.athlete_id AND id != OLD.id) THEN
      -- No other waivers exist, reset the status
      UPDATE athletes 
      SET 
        waiver_signed = false,
        waiver_status = 'pending',
        latest_waiver_id = NULL,
        updated_at = NOW()
      WHERE id = OLD.athlete_id;
      
      RAISE NOTICE 'Reset athlete % waiver_signed status to false after waiver % deletion', OLD.athlete_id, OLD.id;
    ELSE
      -- Other waivers exist, find the latest one
      UPDATE athletes 
      SET 
        latest_waiver_id = (
          SELECT id FROM waivers 
          WHERE athlete_id = OLD.athlete_id 
          ORDER BY created_at DESC 
          LIMIT 1
        ),
        updated_at = NOW()
      WHERE id = OLD.athlete_id;
      
      RAISE NOTICE 'Updated athlete % latest_waiver_id after waiver % deletion', OLD.athlete_id, OLD.id;
    END IF;
  END IF;
  
  RETURN OLD;
END;
$function$;


-- Grant execute permission to service_role
GRANT EXECUTE ON FUNCTION public.reset_athlete_waiver_signed() TO service_role;

-- =============================================================================

-- Fix update_athlete_waiver_signed function - remove SECURITY DEFINER
DROP FUNCTION IF EXISTS public.update_athlete_waiver_signed() CASCADE;

-- Recreate without SECURITY DEFINER:
CREATE OR REPLACE FUNCTION public.update_athlete_waiver_signed()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'public'
AS $function$
BEGIN
  -- Update the athlete's waiver_signed status to true when a waiver is created
  IF NEW.athlete_id IS NOT NULL THEN
    UPDATE athletes 
    SET 
      waiver_signed = true,
      waiver_status = 'signed',
      latest_waiver_id = NEW.id,
      updated_at = NOW()
    WHERE id = NEW.athlete_id;
    
    -- Log the update for debugging
    RAISE NOTICE 'Updated athlete % waiver_signed status to true after waiver % creation', NEW.athlete_id, NEW.id;
  END IF;
  
  RETURN NEW;
END;
$function$;


-- Grant execute permission to service_role
GRANT EXECUTE ON FUNCTION public.update_athlete_waiver_signed() TO service_role;

-- =============================================================================

-- Fix update_athlete_waiver_status function - remove SECURITY DEFINER
DROP FUNCTION IF EXISTS public.update_athlete_waiver_status() CASCADE;

-- Recreate without SECURITY DEFINER:
CREATE OR REPLACE FUNCTION public.update_athlete_waiver_status()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'public'
AS $function$
BEGIN
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        UPDATE athletes 
        SET 
            latest_waiver_id = NEW.id,
            waiver_status = CASE 
                WHEN NEW.signed_at IS NOT NULL THEN 'signed'
                ELSE 'pending'
            END
        WHERE id = NEW.athlete_id;
        RETURN NEW;
    END IF;
    
    IF TG_OP = 'DELETE' THEN
        WITH next_latest AS (
            SELECT id, 
                   CASE WHEN signed_at IS NOT NULL THEN 'signed' ELSE 'pending' END as status
            FROM waivers 
            WHERE athlete_id = OLD.athlete_id 
              AND id != OLD.id
            ORDER BY created_at DESC 
            LIMIT 1
        )
        UPDATE athletes 
        SET 
            latest_waiver_id = COALESCE((SELECT id FROM next_latest), NULL),
            waiver_status = COALESCE((SELECT status FROM next_latest), 'pending')
        WHERE id = OLD.athlete_id;
        RETURN OLD;
    END IF;
    
    RETURN NULL;
END;
$function$;


-- Grant execute permission to service_role
GRANT EXECUTE ON FUNCTION public.update_athlete_waiver_status() TO service_role;

-- =============================================================================


-- =============================================================================
-- RECREATE VIEWS (should now work without SECURITY DEFINER issues)
-- =============================================================================

-- Recreate athletes_with_waiver_status view
DROP VIEW IF EXISTS public.athletes_with_waiver_status CASCADE;

CREATE VIEW public.athletes_with_waiver_status AS
 SELECT a.id,
    a.parent_id,
    a.name,
    a.first_name,
    a.last_name,
    a.date_of_birth,
    a.gender,
    a.experience,
    a.allergies,
    a.photo,
    a.latest_waiver_id,
    a.waiver_status,
    a.created_at,
    a.updated_at,
    w.signed_at AS waiver_signed_at,
    w.parent_id AS waiver_signature_id,
    w.signature AS waiver_signature_data,
    w.relationship_to_athlete,
    w.created_at AS waiver_created_at,
    concat(p.first_name, ' ', p.last_name) AS waiver_signer_name,
        CASE
            WHEN (w.id IS NOT NULL) THEN true
            ELSE false
        END AS waiver_signed,
        CASE
            WHEN (w.id IS NOT NULL) THEN 'signed'::character varying
            ELSE COALESCE(a.waiver_status, 'pending'::character varying)
        END AS computed_waiver_status
   FROM ((athletes a
     LEFT JOIN waivers w ON ((a.latest_waiver_id = w.id)))
     LEFT JOIN parents p ON ((w.parent_id = p.id)));;

GRANT SELECT ON public.athletes_with_waiver_status TO service_role;

-- Recreate booking_waiver_status view
DROP VIEW IF EXISTS public.booking_waiver_status CASCADE;

CREATE VIEW public.booking_waiver_status AS
 SELECT id AS booking_id,
    get_booking_waiver_status(id) AS waiver_status,
    status AS booking_status
   FROM bookings b;;

GRANT SELECT ON public.booking_waiver_status TO service_role;

-- Recreate parents_with_waiver_status view
DROP VIEW IF EXISTS public.parents_with_waiver_status CASCADE;

CREATE VIEW public.parents_with_waiver_status AS
 SELECT p.id AS parent_id,
    p.first_name AS parent_first_name,
    p.last_name AS parent_last_name,
    p.email AS parent_email,
    p.phone AS parent_phone,
    p.emergency_contact_name,
    p.emergency_contact_phone,
    p.created_at AS parent_created_at,
    count(a.id) AS total_athletes,
    count(w.id) AS athletes_with_waivers,
    (count(a.id) - count(w.id)) AS athletes_without_waivers,
    array_agg(json_build_object('athlete_id', a.id, 'athlete_name', COALESCE(concat(a.first_name, ' ', a.last_name), a.name), 'waiver_signed',
        CASE
            WHEN (w.id IS NOT NULL) THEN true
            ELSE false
        END, 'waiver_signed_at', w.signed_at, 'latest_waiver_id', w.id) ORDER BY a.created_at) FILTER (WHERE (a.id IS NOT NULL)) AS athletes_waiver_info
   FROM ((parents p
     LEFT JOIN athletes a ON ((p.id = a.parent_id)))
     LEFT JOIN LATERAL ( SELECT w2.id,
            w2.signed_at
           FROM waivers w2
          WHERE (w2.athlete_id = a.id)
          ORDER BY w2.signed_at DESC
         LIMIT 1) w ON ((a.id IS NOT NULL)))
  GROUP BY p.id, p.first_name, p.last_name, p.email, p.phone, p.emergency_contact_name, p.emergency_contact_phone, p.created_at;;

GRANT SELECT ON public.parents_with_waiver_status TO service_role;

-- =============================================================================
-- VERIFICATION QUERIES
-- =============================================================================

-- Check that no SECURITY DEFINER functions remain:
/*
SELECT 
    n.nspname as schema_name,
    p.proname as function_name,
    CASE p.prosecdef WHEN true THEN 'SECURITY DEFINER' ELSE 'SECURITY INVOKER' END as security_type
FROM pg_proc p
JOIN pg_namespace n ON p.pronamespace = n.oid
WHERE n.nspname = 'public' AND p.prosecdef = true;
*/

-- Check that views exist:
/*
SELECT schemaname, viewname FROM pg_views
WHERE schemaname = 'public'
AND viewname IN ('athletes_with_waiver_status', 'booking_waiver_status', 'parents_with_waiver_status');
*/