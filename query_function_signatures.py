#!/usr/bin/env python3
"""
Query Database for Function Signatures
This script queries the PostgreSQL database to get exact function signatures
for the functions flagged by Supabase's security linter.
"""

import os
import psycopg2
from dotenv import load_dotenv

def main():
    # Load environment variables
    load_dotenv()
    
    # Get database URL
    db_url = os.getenv('DATABASE_URL') or os.getenv('DIRECT_DATABASE_URL')
    if not db_url:
        print('‚ùå ERROR: Neither DATABASE_URL nor DIRECT_DATABASE_URL found in environment')
        return
    
    try:
        # Connect to database
        print('üîó Connecting to database...')
        conn = psycopg2.connect(db_url)
        cursor = conn.cursor()
        
        # List of function names from the security linter
        function_names = [
            'update_site_content_updated_at',
            'insert_booking_athlete',
            'find_duplicate_bookings',
            'unset_waiver_signed_on_waiver_delete',
            'add_athlete_to_booking',
            'remove_athlete_from_booking',
            'get_booking_athletes',
            'handle_focus_area_other',
            'ensure_single_featured_testimonial',
            'update_is_connected_combo',
            'update_updated_at_column'
        ]
        
        print('üîç Querying function signatures...\n')
        
        # Query to get function signatures and current search_path status
        query = """
        SELECT 
            n.nspname as schema_name,
            p.proname as function_name,
            pg_get_function_identity_arguments(p.oid) as arguments,
            CASE 
                WHEN 'search_path=public' = ANY(p.proconfig) THEN 'FIXED'
                WHEN p.proconfig IS NULL THEN 'MUTABLE (needs fix)'
                ELSE 'OTHER CONFIG: ' || array_to_string(p.proconfig, ', ')
            END as search_path_status,
            'ALTER FUNCTION ' || n.nspname || '.' || p.proname || '(' || 
            pg_get_function_identity_arguments(p.oid) || ') SET search_path = public;' as fix_command
        FROM pg_proc p
        JOIN pg_namespace n ON p.pronamespace = n.oid
        WHERE n.nspname = 'public' 
        AND p.proname = ANY(%s)
        ORDER BY p.proname;
        """
        
        cursor.execute(query, (function_names,))
        results = cursor.fetchall()
        
        if not results:
            print('‚ö†Ô∏è  No functions found with the specified names')
            return
        
        print('üìã FUNCTION SIGNATURES AND STATUS:')
        print('=' * 80)
        
        found_functions = []
        fix_commands = []
        
        for row in results:
            schema, func_name, arguments, status, fix_command = row
            found_functions.append(func_name)
            
            print(f'Function: {schema}.{func_name}')
            print(f'Arguments: {arguments or "(no arguments)"}')
            print(f'Status: {status}')
            print(f'Fix Command: {fix_command}')
            print('-' * 40)
            
            if 'MUTABLE' in status:
                fix_commands.append(fix_command)
        
        # Check for missing functions
        missing_functions = set(function_names) - set(found_functions)
        if missing_functions:
            print('\n‚ö†Ô∏è  MISSING FUNCTIONS (not found in database):')
            for func in missing_functions:
                print(f'  - {func}')
        
        # Generate the corrected SQL script
        if fix_commands:
            print('\nüìù GENERATED FIX SCRIPT:')
            print('=' * 80)
            print('-- Auto-generated function search path fixes')
            print('-- Generated by database query for exact signatures\n')
            
            for command in fix_commands:
                print(command)
        else:
            print('\n‚úÖ All functions already have proper search_path set!')
        
        # Additional diagnostic query - check for functions with SECURITY DEFINER
        print('\nüîí CHECKING FOR SECURITY DEFINER FUNCTIONS:')
        print('=' * 80)
        
        security_definer_query = """
        SELECT 
            n.nspname as schema_name,
            p.proname as function_name,
            pg_get_function_identity_arguments(p.oid) as arguments,
            CASE p.prosecdef 
                WHEN true THEN 'SECURITY DEFINER'
                ELSE 'SECURITY INVOKER'
            END as security_type
        FROM pg_proc p
        JOIN pg_namespace n ON p.pronamespace = n.oid
        WHERE n.nspname = 'public' 
        AND p.proname = ANY(%s)
        AND p.prosecdef = true
        ORDER BY p.proname;
        """
        
        cursor.execute(security_definer_query, (function_names,))
        security_results = cursor.fetchall()
        
        if security_results:
            for row in security_results:
                schema, func_name, arguments, security_type = row
                print(f'‚ö†Ô∏è  {schema}.{func_name}({arguments or ""}) - {security_type}')
        else:
            print('‚úÖ No SECURITY DEFINER functions found in the flagged list')
        
        cursor.close()
        conn.close()
        
        print('\nüéØ SUMMARY:')
        print(f'  - Found {len(found_functions)} of {len(function_names)} functions')
        print(f'  - {len(fix_commands)} functions need search_path fixes')
        print(f'  - {len(missing_functions)} functions not found in database')
        
    except Exception as e:
        print(f'‚ùå Error: {e}')

if __name__ == '__main__':
    main()
